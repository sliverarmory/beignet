package main

import (
	"bytes"
	"debug/macho"
	"errors"
	"flag"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
)

func main() {
	var (
		srcPath   = flag.String("src", "", "Path to beignet loader C source")
		outDir    = flag.String("out", "", "Output directory for generated files")
		zigBin    = flag.String("zig", "zig", "zig executable (must provide `zig cc`)")
		keepTmp   = flag.Bool("keep-tmp", false, "Keep temporary build directory (debug)")
		printSize = flag.Bool("print-size", false, "Print generated loader image size to stdout (debug)")
	)
	flag.Parse()

	if *srcPath == "" {
		fatalf("missing -src")
	}
	if *outDir == "" {
		fatalf("missing -out")
	}

	if runtime.GOOS != "darwin" {
		fatalf("this generator currently supports running on darwin only")
	}
	if runtime.GOARCH != "arm64" {
		fatalf("this generator currently supports darwin/arm64 only")
	}

	tmpDir, err := os.MkdirTemp("", "beignet-genstager-*")
	if err != nil {
		fatal(err)
	}
	if !*keepTmp {
		defer os.RemoveAll(tmpDir)
	}

	loaderBin := filepath.Join(tmpDir, "beignet_loader")
	zigCache := filepath.Join(tmpDir, "zig-cache")
	if err := os.MkdirAll(zigCache, 0o755); err != nil {
		fatal(err)
	}

	cmd := exec.Command(*zigBin, "cc",
		"-target", "aarch64-macos",
		"-fno-stack-protector",
		"-fomit-frame-pointer",
		"-fno-exceptions",
		"-fno-sanitize=all",
		"-fblocks",
		"-fPIC",
		"-O0",
		"-o", loaderBin,
		*srcPath,
	)
	cmd.Env = append(os.Environ(),
		"ZIG_GLOBAL_CACHE_DIR="+zigCache,
		"ZIG_LOCAL_CACHE_DIR="+zigCache,
	)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		fatal(err)
	}

	image, entryOffset, err := extractImageAndEntryOffset(loaderBin, "_beignet_loader")
	if err != nil {
		fatal(err)
	}
	if *printSize {
		fmt.Fprintf(os.Stdout, "beignet_loader image: %d bytes, entry offset: 0x%x\n", len(image), entryOffset)
	}

	if err := os.MkdirAll(*outDir, 0o755); err != nil {
		fatal(err)
	}

	outBin := filepath.Join(*outDir, "stager_darwin_arm64.bin")
	if err := os.WriteFile(outBin, image, 0o644); err != nil {
		fatal(err)
	}

	outGo := filepath.Join(*outDir, "stager_darwin_arm64_gen.go")
	if err := os.WriteFile(outGo, []byte(renderGo(entryOffset)), 0o644); err != nil {
		fatal(err)
	}
}

func extractImageAndEntryOffset(path string, entrySymbol string) ([]byte, uint64, error) {
	f, err := macho.Open(path)
	if err != nil {
		return nil, 0, err
	}
	defer f.Close()

	textSeg := f.Segment("__TEXT")
	if textSeg == nil {
		return nil, 0, errors.New("missing __TEXT segment")
	}

	baseAddr := textSeg.Addr

	segs := []*macho.Segment{
		textSeg,
		f.Segment("__DATA_CONST"),
		f.Segment("__DATA"),
		f.Segment("__LINKEDIT"),
	}
	var maxEnd uint64
	for _, seg := range segs {
		if seg == nil {
			continue
		}
		end := seg.Addr + seg.Memsz
		if end > maxEnd {
			maxEnd = end
		}
	}
	if maxEnd <= baseAddr {
		return nil, 0, errors.New("invalid segment layout")
	}

	image := make([]byte, maxEnd-baseAddr)
	for _, seg := range segs {
		if seg == nil {
			continue
		}
		segData, err := seg.Data()
		if err != nil {
			return nil, 0, err
		}
		if uint64(len(segData)) != seg.Filesz {
			return nil, 0, fmt.Errorf("%s filesz mismatch: segment=%d data=%d", seg.Name, seg.Filesz, len(segData))
		}
		if seg.Memsz < seg.Filesz {
			return nil, 0, fmt.Errorf("%s memsz < filesz: memsz=%d filesz=%d", seg.Name, seg.Memsz, seg.Filesz)
		}
		off := seg.Addr - baseAddr
		copy(image[off:off+seg.Filesz], segData)
	}

	entryValue, ok := findSymbolValue(f, entrySymbol)
	if !ok {
		return nil, 0, fmt.Errorf("symbol not found: %s", entrySymbol)
	}
	if entryValue < baseAddr || entryValue >= maxEnd {
		return nil, 0, fmt.Errorf("entry symbol %s not within image (value=0x%x base=0x%x end=0x%x)", entrySymbol, entryValue, baseAddr, maxEnd)
	}
	return image, entryValue - baseAddr, nil
}

func findSymbolValue(f *macho.File, name string) (uint64, bool) {
	if f.Symtab == nil {
		return 0, false
	}
	for _, sym := range f.Symtab.Syms {
		if sym.Name == name {
			return sym.Value, true
		}
	}
	return 0, false
}

func renderGo(entryOffset uint64) string {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, "// Code generated by internal/tools/genstager; DO NOT EDIT.")
	fmt.Fprintln(&buf, "package stager")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "import _ \"embed\"")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "//go:embed stager_darwin_arm64.bin")
	fmt.Fprintln(&buf, "var imageDarwinArm64 []byte")
	fmt.Fprintln(&buf)
	fmt.Fprintf(&buf, "const entryOffsetDarwinArm64 = 0x%x\n", entryOffset)
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "func loaderTextDarwinArm64() ([]byte, uint64) {")
	fmt.Fprintln(&buf, "\treturn imageDarwinArm64, entryOffsetDarwinArm64")
	fmt.Fprintln(&buf, "}")
	return buf.String()
}

func fatal(err error) {
	fatalf("%v", err)
}

func fatalf(format string, args ...any) {
	msg := fmt.Sprintf(format, args...)
	if msg != "" && msg[len(msg)-1] != '\n' {
		msg += "\n"
	}
	io.WriteString(os.Stderr, msg)
	os.Exit(1)
}
